package org.factcenter.qilin.primitives.concrete;

import org.factcenter.qilin.util.BitMatrix;

import java.security.MessageDigest;
import java.util.Random;

/**
 * An implementation of Random that can be used to generate a
 * stream of pseudorandom bytes from a given input.
 * The stream is generated by concatenating a 64-bit index (starting with 0) to the input
 * and then hashing; the random stream returns the hash bytes until they run
 * out, then updates the index.
 */
public class DigestRandom extends Random {
    MessageDigest md;
    BitMatrix currentHash = null;
    int curBit = -1;
    int bitsLeft = 0;
    long counter = 0;

    public DigestRandom(MessageDigest md, byte[] input) {
        this.md = md;

        md.reset();
        md.update(input);
    }


    @Override
    protected int next(int bits) {
        int retVal = 0;

        if (bits > 32)
            bits = 32;

        while (bits > 0) {
            if (bitsLeft == 0) {
                try {
                    MessageDigest md1 = (MessageDigest) md.clone();

                    for (int i = 0; i < 8; ++i)
                        md1.update((byte)((counter >>> i*8) & 0xff));
                    currentHash = new BitMatrix(md1.digest(), 0);
                    ++counter;
                    bitsLeft = currentHash.getNumCols();
                    curBit = 0;
                } catch (CloneNotSupportedException e) {
                    throw new RuntimeException("Can't run oracle when clone is not supported!");
                }
            }
            int read = Math.min(bits, bitsLeft);
            retVal <<= read;
            retVal |= ((int) currentHash.getBits(curBit, read)) & ((1 << read) - 1);
            curBit += read;
            bits -= read;
        }

        return retVal;

    }
}
